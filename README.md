# difficulty-algorithms
See the Issues for difficulty algorithms

This is a mish-mash of code I've done related to difficulty algorithms.  The primary content of this repository is in the issues.

https://github.com/zawy12/difficulty-algorithms/issues/50
Here are all the common difficulty algorithms. All equations (except the int() in ETH) are expressed as floating point to make the mathematical relationships clear. The various limits on timespans, timestamps, and target changes are not included (and should not be used anyway because they are almost never beneficial and always allow timestamp exploits).

ASERT appears to be the only perfectly correct difficulty algorithm. See bottom for a full discussion.

All the algorithms can be converted to an "RTT" (Real Time Target) by making the most recent timestamp in the calculations tN+1 instead of tN. This means the difficulty depends at least partially on the timestamp in the same block. This can probably make any algorithm better if timestamp rules are tight enough to limit manipulation.

TSA is the only algorithm shown below that is explicitly meant to be an RTT. It is a fast-responding ASERT inside of a normal slow ASERT. To use it, the ASERT value will be the "official" difficulty for the block that is used to calculate chain work and to be the target used for the next block's ASERT calculation. The sub_target is the "actual" difficulty the miner has to solve for the block. It depends on the timestamp the miner assigns to the same block. P in TSA is a value less than M that causes the difficulty to be higher than the ASERT value if the solvetime is too fast, and lower if the solvetime has been taking too long. The TSA can be similarly done in terms of a fast EMA inside a slow EMA (or an LWMA). See my TSA article for more detail such as how to handle timestamp manipulation.

Testing ranks the ability of the algorithms from worst to best like this:
BTC/LTC
SMA
Digishield, Grin, KGW, BRNDF
ETH (solvetime 15% too fast under severe attack)
EMA, ASERT, LWMA
TSA (an RTT)

The method of testing first puts them on equal terms by adjusting their primary parameter to has the same Std Dev in difficulty under constant hashrate conditions. For example, I found experimentally that ASERT & EMA's M give the same stability as SMA when M =~ N/2. Wikipedia says this is because M=(N+1)/2 is where EMA as the same "center of mass" as an SMA. Once the "averaging window" parameter that gives the same stability if set, the DAs are compared under on-off mining "attack" conditions. I then look at how well they prevent attackers from getting lower targets per hash (using time-weighted target averaging) and how well they prevent delays (defined by me as percent of time waiting more than 4x target solvetime.

KGW and BRNDF reduce the SMA window to "i" blocks if the avg T/solvetime ratio is > A or < 1/A where A = 1+0.7048*(i/144)^(-1.228), and "i" might need to be at least some min like 36.

https://user-images.githubusercontent.com/18004719/70812473-abed2700-1d95-11ea-9171-be6841bab137.png

Problems in the uncorrected forms of the algos:

ETH originally had a DA that someone intuitively guessed at that did not give the correct solvetime and had another problem. The updated Homestead version mostly corrected the two problems by very reasonable changes. My equation includes a ln(2) that shows a correct solvetime is derivable, despite only changing if solvetime is a multiple of T. It's an approximation of the "perfectly correct" ASERT not ony via the EMA approximation AND decimal round-off, but it's also the inverted form of the EMA that makes use of the additional approximation 1+x =~ 1/(1-x) for small x. This enables the possibility of negative of negative difficulties which is protected in ETH with a 99 factor. But that correction opens up the possibility if a >50% attacker's selfish mine getting 75% more blocks than a selfish mine in an algo that does not have a problem. My equation above corrects these errors and is discussed here.
DGW (Dark Gravity Wave) uses a horrendous loop calculation that is just an SMA that gives double weight to most recent target value which has almost no effect. I have an article on it here.
KGW (Kimoto Gravity Well) changes the size of the averaging window if solvetimes are too fast or too slow. It's a potentially very good idea, but no justification is used for the curve that decides when to use the smaller averaging windows. It seems to work OK. It has an out-of-sequence timestamp block that allows a catastrophic exploit if timestamps are not required to be sequential in the protocol. I'm not sure anyone is aware of this which seems to be a separate issue from past complaints. The BRNDF version in Zcoin prevents it from changing more than once per 12 blocks which should cause oscillations if there is a lot of switchable hashrate that could attack it, but Zcoin is not experiencing any problem while ranking "only" 107 in market capitalization ($28 M today, with BTC emission rate).
Digishield as usually implemented includes a 6-block delay in the window of the solvetimes it uses. This causes tolerable oscillations. The reason for the delay is to make sure solvetimes are in sequence (which prevents a catastrophic exploit on timespan limits that BTC/LTC/BCH/KGW/DGW have). There are two other methods that could and should have been used to prevent the delay and therefore oscillations. The equation I have above does not include the delay. The delay makes it worse than merely ranking as low as KGW but both work better than SMA and coins do not usually see any problem with them. It also has 16% and 32% useless timespan limits that force a 500 block delay in it reaching the correct solvetime if difficulty changes a lot such as in genesis. I have an article on it here.
BTC/LTC have several problems. Biggest problem is that it's not even an SMA rolling average. This has kept BTC 6.6% ahead of coin emission schedule due to difficulty always rising and it not responding fast enough. Small coins attempting this algorithm quickly realize they will have to fork to replace it. BTC has the Zeitgeist hole in it and BTC/LTC both have an additional N/(N-1) over-estimate in the difficulty (underestimate in target) due to the exponential distribution having more fast solvetimes than slow ones in a finite N sample. see this.
SMA (Simple Moving Average) is more likely to have bad oscillations. The smaller the sampling window is, the larger the error. The error can be approximately correct for N>3 by a (1+3/N^2) factor multiplied by the target.
Monero / Cryptonote is an SMA but some awful modifications were made. All small and even most medium coins using it have to replace it. The problem is that it has a cut and lag that prevent it from considering recent solvetimes especially under on-off mining conditions. This results in oscillations that are not merely stable as in Digishield and an SMA, but oscillations that amplify, typically resulting in a small coin getting stuck. My LWMA became well-known as coins abandoning this algo became aware of similar cryptonote coins using LWMA.
EMA/ASERT are the preferred algorithm, but you have to be careful in using it. Cryptonote coins can't use it because they have a 1 delay in the timestamps. I have an article here that in part discusses all the potential problems. "EMA" comes from Jacob Eliosoff's attempt to create an EMA for DAs. A simple attempt fails but he used deeper thinking. I noticed it closely resembles a section in Wikipedia that eis similarly not obviously applicable to DAs. Tom Harding and Kyuupichan worked to improve it and ended up with the simpler form I show above that is nearly as accurate but does not need the e^x function. Jacob also thought of the ASERT but did not pursue it due to the similarity and e^x. Mark Lundeberg and Dragos Ilie (et al at Imperial College) independently thought of what myself and others believe is the perfect algorithm. Amazingly, it needs only the current timestamp and the genesis block's difficulty, i.e. D = D0 * e^((N*T-timestamp)/M) which Mark showed is mathematically equal to ASERT. BTW, there are several other names for M or 1/M (aka "alpha" in EMAs) in various fields of science like survival or extinction coefficient, time constant in an RC filter, turbidity coefficient for light passing through gases or liquids, and "half life" if 2^(-t/M) is used. In this case, M is a "turbidity" or "filter" to the difficulty adjusting to the correct value in response to a hashrate change.
LWMA's only fault is that it's more complicated than EMA/ASERT. It is mathematically not too different from ASERT.
// LWMA math without using a loop. I have not checked this.
k = N/2*(N+1)
S = D_N / [ D_{N-2} + D_{N-1}/N - D_{-1}/N ] * k * T
D_{N+1} = [ D_{N-1} + D_N/N - D_0/N ] * T * k / 
[ S - (ts_{N-1}-ts_0) + (ts_N-ts_{N-1})*N ]
TSA-RTT is by far and away the best difficulty algorithm but there is a lot of resistance to using it do to changing the difficulty based on the timestamp submitted. Only a few coins do something like this. The timestamps must be forced to be sequential and how far a timestamp is ahead of a validating node's time (the Future Time Limit - FTL) must be small compared to how large a reduction in difficulty it will allow. It must also be used with LWMA, ASERT, or EMA (ideally ASERT) so that a private mine can't do a sequence of timestamps that gives an advantage that is greater than his hashrate. If it changes too much, the distribution of solvetimes will have a peak around the goal, making accurate solvetimes, but this causes more orphans. Also, if the FTL is not small enough, all miners with target that limit, again causing orphans. I cover it here.
Timespan Limit Problem. All coins need to require timestamps to be sequential or use what I can "kyuupichan's method". This is to prevent various attacks, but especially the timespan limit attack that I describe here that allows a > 50% selfish mining attacker to get unlimited blocks in < 3x the difficulty window in all algorithms that have timespan limits and do not prevent out of sequence timestamps.
* This is calculated by time-weighted attacker's average target divided by time-weighted avg of all targets. That is, % unfair gains = sum(target_when_attacker_was_active * time_at_attackers_target) / sum(each_target*time_at_each_target/total time) . The specific test for the rankings used a miner motivation equation to model the apparent motivation in BCH's 2019 on-off mining problem. Specifically, it says "Begin 6x avg hashrate mining if difficulty (1/target) is 130% of average difficulty that the 1x hashrate miners would have if there was no on-off mining, and stop when it is 135%. I also ran other tests such as start and stop on 95% and 105%.

Latex for the equations:

\text{t = timestamp, tar = target, T = target blocktime} \\
next\_tar = previous\_target\ *\ \frac{t_N-t_0}{NT}*\frac{N}{N-1} \text{ \ \ \ (BTC w/ 2 corrections)}
\\
tar_{N+1} = avg\_N\_targets\ *\ \frac{t_N-t_0}{NT} \text{ \ \ \ (SMA, DGW corrected) }  \\
\text{If past i blocks were too fast or too slow, reduce N to i in SMA.  \ \ (KGW, BRNDF)}
\\
tar_{N+1} = avg\_N\_targets\ *\ (1\ +\ \frac{t_{N}-t_{0}}{MTN}\ -\ \frac{1}{M}) \text{ \ \ (Digishield M=4, Grin M=2) } \\
tar_{N+1} = tar_N*(1+\frac{t_{N} - t_{N-1}}{MT} - \frac{1}{M})\text{ \ \ \ (EMA) } \\
tar_{N+1} = tar_N\ *\ (1\ +\ int(\frac{t_{N}-t_{N-1}}{T})*\frac{1}{M*ln(2)}\ -\ \frac{1}{M})\text{ \ \ \ (ETH, corrected) } \\
tar_{N+1} = avg\_N\_targets\ *\ \frac{N(N+1)}{2T}\sum_{i=1}^{N} i*(t_i-t_{i-1})  \text{ \ \ \ (LWMA) } \\
tar_{N+1} = tar_N*\left[e^{(t_{N} - t_{N-1})/T - 1} \right]^\frac{1}{M}  \text{ \ \ \ (ASERT) } \\
sub\_tar_{N+1} = \text{ASERT}*\left[e^{(t_{N+1} - t_{N})/T - 1} \right]^\frac{1}{P} \text{\ \ (TSA RTT)}\\

Discussion of why and in what sense ASERT is the "perfectly correct" difficulty algorithm.
The other algorithms are just approximations to what ASERT does. EMA is very close to ASERT as can be seen by using the approximation e^x = 1+ x in ASERT to get EMA which is valid for small x (e.g. M>20). The corrected ETH algorithm is an integer truncation of the EMA that gives surprisingly acceptable results. ASERT was devised by Mark Lundeberg @markblundeberg (he'll publish a public PDF on it sometime). ASERT appears to be the ratio of the expected to the observed solvetime distributions. That is, in terms of targets, it's e^-1 divided by e^(-solvetime/T). There is also a "smoothing" power factor of 1/M to make it more stable (aka respond more slowly). Intuitively, the 1/M appears correct because adjusting the target every block uses multiplication that builds upon past multiplications of the roots of the ratios. ASERT's expected maximum rate of change is a factor of e in M blocks. LWMA rises about 50% faster and falls about 50% more slowly, which can be good and bad.

ASERT is the only algorithm that gives the perfectly correct solvetime no matter how slow or fast it is made to respond by adjusting the M factor, and no matter how much hashrate changes, except it gets behind M blocks for every 2.718x permanent increase in hashrate. All algorithms will have that type of except for a dangerous one that predicts increases in hashrate and thereby trying to adjust ahead of time. BTC/LTC can also get the correct long term average solvetime if a N/(N-1) correction factor in target is applied, but it is not as accurate on a per block basis because it is not changing every block, and there does not appear to be a valid adjustment for N=1 (a division by zero) that ASERT can do. The N/(N-1) is an explicit correction factor. All the algos can similarly get the correct long-term average solvetime if a correction factor based on N and/or solvetime is applied, but this appears to be approximating ASERT. Also, all the algos that use more than just the previous target like ASERT, EMA, and ETH will give a different result if there is an attempt to apply the inverse of the equation directly to difficulty. To get the same result they have to use the harmonic mean of difficulties which gives the mean target. These are my observational and pseudo-theoretical argument for why ASERT is the only mathematically correct difficulty algorithm, assuming we do not make assumptions or predictions about miner motivation.
